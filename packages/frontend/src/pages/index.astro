---
import '../styles/global.css';
import { Button } from '@/components/ui/button';
import Navigation from '@/components/Navigation.vue'
import { SidebarProvider, SidebarTrigger } from "@/components/ui/sidebar"
import { Image } from 'astro:assets'
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>Kinnaird.scot</title>
	</head>

	<body>
		<div class="flex flex-row h-screen">
				<div class="h-screen flex-none">
					<Navigation client:load>
                                        	<Image slot="logo" class="w-6 max-h-6 rounded-md object-contain flex-shrink-0" width="40" height="40" src="https://gravatar.com/avatar/af209d37d6bc17d6e3f3b2210f3e24da96afcd2eb3617a315eea641e9e9cc09c" alt="Peter Kinnaird Logo" loading="eager"/>
					</Navigation>
				</div>
				<div class="flex-1 p-0 m-0 relative">
					<canvas id="webgl-canvas" class="rotate-1 absolute inset-0 w-screen h-96 -left-2 opacity-60"></canvas>
					<h1 class="relative z-10 p-4">Peter Kinnaird</h1>  <!-- Added relative positioning and padding to h1 -->
				</div>
		</div>

		<script is:inline>
			const canvas = document.getElementById('webgl-canvas');
			const gl = canvas.getContext('webgl');

			if (!gl) {
				console.error("Unable to initialize WebGL. Your browser or machine may not support it.");
			} else {
				// Vertex shader program
				const vsSource = `
					attribute vec4 aVertexPosition;
					void main(void) {
						gl_Position = aVertexPosition;
					}
				`;

				// Fragment shader program
				const fsSource = `
					precision mediump float;

					uniform vec2 u_resolution;
					uniform float u_time;

					// Simple pseudo-random function (hash)
					float random (vec2 st) {
						return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
					}

					void main(void) {
						vec2 st = gl_FragCoord.xy / u_resolution.xy; // Normalized coordinates (0.0 to 1.0)
						vec4 color1 = vec4(1.0, 0.2, 0.4, 1.0);
						vec4 color2 = vec4(0.5, 0.3, 0.0, 1.0);
						vec4 color_base = vec4(0.1, 0.5, 0.6, 1.0);
						float time = u_time * 0.001; // Convert time from ms to seconds

						vec4 c1_base = 0.5 + 0.5 * sin(time + st.x * 3.14) * color1;
						vec4 c2_base = 0.5 + 0.5 * cos(time + st.y * 3.14) * color2;
						vec4 c3_base = 0.5 + 0.5 * cos(time + (st.x + st.y) * 1.57) * color2;

						float r_base = 0.5 + 0.5 * sin(time + st.x * 3.14);
						float g_base = 0.5 + 0.5 * sin(time + st.x * 3.14);
						float b_base = 0.5 + 0.5 * cos(time + (st.x + st.y) * 1.57);

						// Generate noise based on position and time
						float noise = random(st + vec2(time * 0.1, time * 0.05)); // Add time to make noise dynamic

						gl_FragColor = mix(c1_base, c2_base, time * 0.1) * noise;
					}
				`;

				// Initialize shaders
				function loadShader(gl, type, source) {
					const shader = gl.createShader(type);
					gl.shaderSource(shader, source);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
						gl.deleteShader(shader);
						return null;
					}
					return shader;
				}

				const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
				const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

				// Create shader program
				const shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
				}

				// Look up vertex position attribute
				const programInfo = {
					program: shaderProgram,
					attribLocations: {
						vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
					},
					uniformLocations: {
						resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
						time: gl.getUniformLocation(shaderProgram, 'u_time'),
					},
				};

				// Create buffer for a rectangle covering the canvas
				const positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				const positions = [
					 1.0,  1.0,
					-1.0,  1.0,
					 1.0, -1.0,
					-1.0, -1.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

				// --- Animation Loop ---
				let startTime = performance.now();

				function render(currentTime) {
					const elapsedTime = currentTime - startTime;

					// Resize canvas if needed (optional, but good practice)
					const displayWidth  = canvas.clientWidth;
					const displayHeight = canvas.clientHeight;
					if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
						canvas.width = displayWidth;
						canvas.height = displayHeight;
						gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
					}

					// Clear the canvas
					gl.clearColor(0.0, 0.0, 0.0, 0.0); // Clear to transparent black
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Tell WebGL how to pull out the positions from the position buffer
					{
						const numComponents = 2;
						const type = gl.FLOAT;
						const normalize = false;
						const stride = 0;
						const offset = 0;
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						gl.vertexAttribPointer(
							programInfo.attribLocations.vertexPosition,
							numComponents,
							type,
							normalize,
							stride,
							offset);
						gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
					}

					// Tell WebGL to use our program
					gl.useProgram(programInfo.program);

					// Set the shader uniforms
					gl.uniform2f(programInfo.uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
					gl.uniform1f(programInfo.uniformLocations.time, elapsedTime);

					// Draw the rectangle
					{
						const offset = 0;
						const vertexCount = 4;
						gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
					}

					// Request the next frame
					requestAnimationFrame(render);
				}

				// Start the animation
				requestAnimationFrame(render);
			}
		</script>
	</body>
</html>
