---
import '../styles/global.css';
import { Button } from '@/components/ui/button';
import Navigation from '@/components/Navigation.vue'
import { SidebarProvider, SidebarTrigger } from "@/components/ui/sidebar" // Keep imports
import { Image } from 'astro:assets'
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>Kinnaird.scot</title>
	</head>

	<body>
		<SidebarProvider :defaultOpen="false" client:load> {/* Add Provider wrapper */}
			<div class="flex flex-row h-screen">
					<div class="h-screen flex-none p-2"> {/* Add padding for trigger */}
						<SidebarTrigger class="size-6 mb-2" /> {/* Add Trigger here */}
						<Navigation client:load>
							<Image slot="logo" class="w-6 max-h-6 rounded-md object-contain flex-shrink-0" width="40" height="40" src="https://gravatar.com/avatar/af209d37d6bc17d6e3f3b2210f3e24da96afcd2eb3617a315eea641e9e9cc09c" alt="Peter Kinnaird Logo" loading="eager"/>
						</Navigation>
					</div>
					<div class="flex-1 p-0 m-0">
						<div class="flex flex-col h-screen">
						<div class="flex-1 h-1/4 w-1/4">&nbsp;</div>
						<div class="flex flex-row flex-none h-1/2">
					 		<div class="hidden md:flex flex-1 h-1/4 w-1/4">&nbsp;</div>
							<div class="flex-none w-full md:w-1/2">
								<div class="p-4">
					  				<h1 class='text-3xl font-extralight font-mono'>Peter Kinnaird - Software Engineer</h1>  <!-- Added relative positioning and padding to h1 -->
									<p class='font-light'>Peter is an Engineer and Architect from Glasgow, Scotland</p>
								</div>
							</div>
							<div class="hidden md:flex flex-1 h-1/4 w-1/4"></div>
						</div>
					<div class="flex-1 h-1/4 w-1/4"></div>
					<!-- <canvas id="webgl-canvas" class="rotate-1 absolute inset-0 w-screen h-1/4 -left-2 opacity-60"></canvas> -->
					<!-- <canvas id="webgl-canvas" class="rotate-1 absolute inset-0 w-screen h-1/4 -left-2 opacity-60"></canvas> -->
				</div>
			</div>
		</SidebarProvider> {/* Close Provider wrapper */}

		<script is:inline>
			// const canvas = document.getElementById('webgl-canvas'); // Keep canvas code commented out
			const gl = canvas.getContext('webgl');

			if (!gl) {
				console.error("Unable to initialize WebGL. Your browser or machine may not support it.");
			} else {
				// Vertex shader program
				const vsSource = `
					attribute vec4 aVertexPosition;
					void main(void) {
						gl_Position = aVertexPosition;
					}
				`;

				// Fragment shader program
				const fsSource = `
					precision mediump float;

					uniform vec2 u_resolution;
					uniform float u_time;

					// The random function was removed as it was unused and causing a compile error.

					void main(void) {
						vec2 st = gl_FragCoord.xy / u_resolution.xy; // Normalized coordinates (0.0 to 1.0)
						float time = u_time * 0.0005; // Slow down time a bit

						float wave_frequency = 4.0;   // How many waves horizontally
						float wave_amplitude = 0.15;  // How wide the wave swings vertically
						float wave_speed = 1.5;       // How fast the wave moves horizontally

						// Calculate the vertical center of the wave based on horizontal position (st.x) and time
						float wave_center_y = 0.5 + sin(st.x * wave_frequency * 3.14159 + time * wave_speed) * wave_amplitude;

						// --- Blurred Band Calculation ---
						float band_width = 1.0; // The solid part of the band
						float blur_width = 0.00; // The faded edge width on each side

						// Calculate the edges for smoothstep (now based on y-coordinate)
						float edge0 = wave_center_y - band_width / 2.0 - blur_width;
						float edge1 = wave_center_y - band_width / 2.0;
						float edge2 = wave_center_y + band_width / 2.0;
						float edge3 = wave_center_y + band_width / 2.0 + blur_width;

						// Use smoothstep to create the blurred band intensity (0 outside, 1 inside)
						// smoothstep(a, b, y) goes from 0 to 1 as y goes from a to b
						// We create a rising edge (edge0 to edge1) and subtract a falling edge (edge2 to edge3)
						float intensity = smoothstep(edge0, edge1, st.y) - smoothstep(edge2, edge3, st.y);

						// --- Color ---
						vec4 wave_color1 = vec4(0.9, 0.6, 0.9, 1.0); // A nice blue color
						vec4 wave_color2 = vec4(0.9, 0.2, 0.2, 1.0);
						vec4 wave_color = mix(wave_color1 * sin(st.x * time) * 3.14, wave_color2 * cos(st.y * time) * 3.14, intensity);
						vec4 background_color = vec4(0.0, 0.0, 0.0, 0.0); // Transparent background

						// Mix the background and wave color based on the calculated intensity
						vec4 final_color = mix(background_color, wave_color, intensity);

						gl_FragColor = final_color;
					}
				`;

				// Initialize shaders
				function loadShader(gl, type, source) {
					const shader = gl.createShader(type);
					gl.shaderSource(shader, source);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
						gl.deleteShader(shader);
						return null;
					}
					return shader;
				}

				const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
				const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

				// Create shader program
				const shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
				}

				// Look up vertex position attribute
				const programInfo = {
					program: shaderProgram,
					attribLocations: {
						vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
					},
					uniformLocations: {
						resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
						time: gl.getUniformLocation(shaderProgram, 'u_time'),
					},
				};

				// Create buffer for a rectangle covering the canvas
				const positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				const positions = [
					 1.0,  1.0,
					-1.0,  1.0,
					 1.0, -1.0,
					-1.0, -1.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

				// --- Animation Loop ---
				let startTime = performance.now();

				function render(currentTime) {
					const elapsedTime = currentTime - startTime;

					// Resize canvas if needed (optional, but good practice)
					const displayWidth  = canvas.clientWidth;
					const displayHeight = canvas.clientHeight;
					if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
						canvas.width = displayWidth;
						canvas.height = displayHeight;
						gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
					}

					// Clear the canvas
					gl.clearColor(0.0, 0.0, 0.0, 0.0); // Clear to transparent black
					gl.clear(gl.COLOR_BUFFER_BIT);

					// Tell WebGL how to pull out the positions from the position buffer
					{
						const numComponents = 2;
						const type = gl.FLOAT;
						const normalize = false;
						const stride = 0;
						const offset = 0;
						gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
						gl.vertexAttribPointer(
							programInfo.attribLocations.vertexPosition,
							numComponents,
							type,
							normalize,
							stride,
							offset);
						gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
					}

					// Tell WebGL to use our program
					gl.useProgram(programInfo.program);

					// Set the shader uniforms
					gl.uniform2f(programInfo.uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
					gl.uniform1f(programInfo.uniformLocations.time, elapsedTime);

					// Draw the rectangle
					{
						const offset = 0;
						const vertexCount = 4;
						gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
					}

					// Request the next frame
					requestAnimationFrame(render);
				}

				// Start the animation
				requestAnimationFrame(render);
			}
		</script>
	</body>
</html>
