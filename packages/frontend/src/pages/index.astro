---
import '../styles/global.css';
import { Button } from '@/components/ui/button';
import Navigation from '@/components/Navigation.vue'
import { SidebarProvider, SidebarTrigger } from "@/components/ui/sidebar"
import { Image } from 'astro:assets'
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>Kinnaird.scot</title>
	</head>

	<body>
		<div class="flex flex-row h-screen">
				<div class="h-screen flex-none">
					<Navigation client:load>
                                        	<Image slot="logo" class="w-6 max-h-6 rounded-md object-contain flex-shrink-0" width="40" height="40" src="https://gravatar.com/avatar/af209d37d6bc17d6e3f3b2210f3e24da96afcd2eb3617a315eea641e9e9cc09c" alt="Peter Kinnaird Logo" loading="eager"/>
					</Navigation>
				</div>
				<div class="flex-1 p-0 m-0 relative">
					<canvas id="webgl-canvas" class="absolute inset-0 w-full h-full"></canvas>
					<h1 class="relative z-10 p-4">Peter Kinnaird</h1>  <!-- Added relative positioning and padding to h1 -->
				</div>
		</div>

		<script is:inline>
			const canvas = document.getElementById('webgl-canvas');
			const gl = canvas.getContext('webgl');

			if (!gl) {
				console.error("Unable to initialize WebGL. Your browser or machine may not support it.");
			} else {
				// Vertex shader program
				const vsSource = `
					attribute vec4 aVertexPosition;
					void main(void) {
						gl_Position = aVertexPosition;
					}
				`;

				// Fragment shader program
				const fsSource = `
					void main(void) {
						gl_FragColor = vec4(0.1, 0.2, 0.3, 1.0); // Example color (dark blueish)
					}
				`;

				// Initialize shaders
				function loadShader(gl, type, source) {
					const shader = gl.createShader(type);
					gl.shaderSource(shader, source);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
						gl.deleteShader(shader);
						return null;
					}
					return shader;
				}

				const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
				const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

				// Create shader program
				const shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
				}

				// Look up vertex position attribute
				const programInfo = {
					program: shaderProgram,
					attribLocations: {
						vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
					},
				};

				// Create buffer for a rectangle covering the canvas
				const positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				const positions = [
					 1.0,  1.0,
					-1.0,  1.0,
					 1.0, -1.0,
					-1.0, -1.0,
				];
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

				// --- Drawing ---
				// Set canvas size (important for resolution)
				canvas.width = canvas.clientWidth;
				canvas.height = canvas.clientHeight;
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

				// Clear the canvas
				gl.clearColor(0.0, 0.0, 0.0, 0.0); // Clear to transparent black initially
				gl.clear(gl.COLOR_BUFFER_BIT);

				// Tell WebGL how to pull out the positions from the position buffer
				{
					const numComponents = 2; // pull out 2 values per iteration
					const type = gl.FLOAT; // the data in the buffer is 32bit floats
					const normalize = false; // don't normalize
					const stride = 0; // how many bytes to get from one set of values to the next
					const offset = 0; // how many bytes inside the buffer to start from
					gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
					gl.vertexAttribPointer(
						programInfo.attribLocations.vertexPosition,
						numComponents,
						type,
						normalize,
						stride,
						offset);
					gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
				}

				// Tell WebGL to use our program
				gl.useProgram(programInfo.program);

				// Draw the rectangle
				{
					const offset = 0;
					const vertexCount = 4;
					gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount);
				}
			}
		</script>
	</body>
</html>
